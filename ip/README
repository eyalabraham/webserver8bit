
I wrote this IP stack after trying out the LwIP stack for my project hosted on SAVANNAH:
https://savannah.nongnu.org/projects/lwip/ or http://www.nongnu.org/lwip/2_0_x/index.html.
LwIP was not light weight enough for my needs, and the documentation, IMHO,
was less than adequate for debugging issues. While functions and data structures
were nicely documented, the examples and wiki were often out dated.
LwIP 2.0.2 was too convoluted for my needs to support a simple ethernet interface
in a DOS environment, and within my home-brew multi-tasking executive.
This stack borrows several implementation ideas from LwIP.

The structure of the code modules follows the OSI model, with as much flexibility as I thought
would be useful. The framework can be extended for features such as more than one ethernet interface,
or varying amounts of resources dedicated to TCP connections, an ARP table size, etc.

Each module matches a layer in the OSI model, and 'plugs into' a common 'stack' module.
The 'stack' module implements only IPv4, and supplies all the data structures and utilities 
that are used to run the stack: such as timers, setup/init code and so on.
The stack module follows the LwIP model of call-backs. This model fit my needs for running the stack
in a single threaded environment with no OS. This stack will be able to run in my FlashLite NEC v25
8bit SBC DOS or my home-brew multi-task executive (https://sites.google.com/site/eyalabraham/robotics#software).
In both cases the stack will be running as an isolated single thread.

A rough ASCII sketch of the architecture and associated files:

 +--------------------------+-------------------------------+
 | Stack common components  | Application                   |
 | ~~~~~~~~~~~~~~~~~~~~~~~~ | ~~~~~~~~~~~~                  |
 | stack.c                  |                               |
 | stack.h                  |                               |
 | options.h                |                               |
 | error.h                  |                               |
 | types.h                  +-----------/\--------------\/--+
 |                          | Transport                     |
 |                          | ~~~~~~~~~~                    |
 |                          | udp.c  tcp.c  icmp.c          |
 |                          | udp.h  tcp.h  icmp.h          |
 |                          |                               |           ip4_output()
 |                          +-----------/\--------------\/--+ <----- [registered function per transport]
 |                          | Network                       |
 |                          | ~~~~~~~~                      |
 |                          | ipv4.c                        |
 |                          | ipv4.h                        |
 |                          |                               |           arp_output()
 |                          +-----------/\----------+---\/--+-+ <--- ip4_input()
 |                          |                       |         |
 |                          | Physical & Data Link  | ARP     |
 |                          | ~~~~~~~~~~~~~~~~~~~~~ | ~~~~~~~ |
 |                          | netif.c               | arp.c   |
 |                          | netif.h               | arp.h   |
 |                          |                       |         |         link_output()
 |                          | enc28j60.c            +-------+-+ <--- arp_input()
 |                          | enc28j60.h                    |
 |                          | enc28j60-hw.h                 |
 |                          |                               |           link_output()
 |                          +-----------/\--------------\/--+ <----- interface_input()
 |                          |                               |
 |                          | Link HW driver                |           link_output()
 +--------------------------+-------------------------------+ <----- link_input()

 Sections
-----------------------------------------
 1. ENC28J60 driver
 2. Network interface (netif)
 3. ARP
 
@@. IPv4 stack common components
    File list


 1. ENC28J60 driver
-----------------------------------------
The driver structure borrows a lot from the LwIP driver skeleton provided with the LwIP source code.
This is simply because I had the driver written, and chose to reuse the code more or less as is.
The driver module contains two stack interface functions: link_output() and link_input().
low_level_input() is called periodically by the network interface function interface_input(). The function checks
the network device for the waiting packets and reads them into a buffer.
link_output() is a function that will be called by the stack when data packets need to be transmitted.
link_output() is linked to the stack through the net_interface_t 'linkoutput' member,
and is intended to send data as-is. When data packets need to be sent and require address resolution (adding
source and destination MAC addresses) the function linked to the 'output' member should be used; this function
runs through address resolution first and then calls link_output() through 'linkoutput' member.
The link_state() will test the link condition and return 'up' (1) or 'down' (0) condition. This function should
also be called repeatedly from within the same loop as interface_input(), and the code should take action if link
state has changed from the last poll.

 2. Network interface (netif)
-----------------------------------------
The network interface module is a common code module for any driver.
There is a one-to-one relationship between driver and network interface because the driver
functions for input and output will be accessed through a common net_interface_t structure.
The network interface module (netif.c) exposes two functions: interface_init() and interface_input().
The interface_init() function is used to initialize the interface. It calls the driver enc28j60Init() for the
chip initialization.
The interface_input() function will be used to poll for input packets. It will either return immediately if no
packets are waiting to be read from the interface HW, or read a waiting packet and forward it up the stack.
This function should be called repeatedly in the main program inside an infinite loop so that it can periodically
poll the interface. There is no support for an interrupt driven setup.

 3. ARP
-----------------------------------------
@@ ('Gratuitous ARP' in not implemented)

@@. IPv4 stack common components
-----------------------------------------
The IPv4 stack functions are typically separated according to the layer they act in. The ASCII diagram has the
module names listed in the appropriate stack locations.
The stack has several utility functions that are common to all or most layers such as timers, buffer allocation, etc.,
which are all located in the ip4stack.c module.

Buffer allocation
    I chose to use a very simple, probably also wasteful, buffer allocation schema.
    The allocation is done from statically allocated (optionally a dynamic allocation) set of
    buffers of a know size. I chose 1536 bytes per buffer because it aligns with the CPU addressing
    and is large enough for a single size IO packet. This way there is no chaining of smaller buffers and processing is simpler.
    There are two sets of buffers: transmit and receive, and the count can be set in options.h header file.
    Allocation is done from the pool of buffers with calls to allocatePbuf() and freePbuf() ;-)
    The options set the receive buffer count to 1 because the ENC28J60 I use has up to 8K byte of possible memory
    buffering, out of which I provisioned 5K byte for receive frames and 3K byte (2 x frame sizes) for transmit buffer.

System time and timer  functions
    @@

Stub input and output functions
    @@

To-Dos
-----------------------------------------
1.  Implement Gratuitous ARP
2.  Error handling
    - remove all assert() and replace with error handling code
    - before forwarding packet to IP layer, check that the dest. IP matches our IP
      if not there is a possible misconfigured ARP table somewhere
3.  Document
    - ARP
    - Timers and system time
4.  Add functions to inerface_ to set IP addr, Gateway and Subnet Mask
5.  Code ICMP response
6.  Code ARP table LRU algorithm to evict slots when the table is full
7.  figure out what's needed: arp_add_... vs. arp_update_...
8.  Add if ( != NULL) on function pointers before calling
9.  A way trace packet drops
10. IP layer: ICMP (to enable 'ping' application), UDP, and TCP
11. interface_link_state() should call the link state function through a pointer,
    the current implementation calls the enc26j60 function directly
12. add code to interface_link_state() or other function to set link state in the interface
    structure and act by calling a registered callback
      
 File list
-----------------------------------------

README

    This file

arp.c
arp.h

    Ethernet ARP protocol module.
       
enc28j60.c
enc28j60.h
enc28j60-hw.h

    Microchip ENC28J60 device driver and driver functions for read/write of data packets.

error.h

    defined stack wide error code enumeration type

ipStackFiles.mk

    Make helper file with file lists for build/compile
    
netif.c
netif.h

    Data link and interface module. call HE initialization, link bring up and
    link level input/output

options.h

    IP stack options borrowing from LwIP options files
    The options header should be included with every IP stack code module and is
    required for building IP stack modules.

stack.c
stack.h

    IPv4 stack code module and header file.

types.h

    defines stack wide data types and data structures
